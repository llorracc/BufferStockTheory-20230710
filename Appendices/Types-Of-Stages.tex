% -*- mode: LaTeX; TeX-PDF-mode: t; -*-
% (setq TeX-parse-self t)
\input{./.econtexRoot}\documentclass[\econtexRoot/BufferStockTheory]{subfiles}
\input{./.econtexRoot}\input{\LaTeXInputs/econtex_onlyinsubfile}
\onlyinsubfile{\externaldocument{\LaTeXGenerated/BufferStockTheory}} % Get xrefs -- esp to appendix -- from main file; only works properly if main file has already been compiled;

% \renewcommand{\LtxDir}{}
\onlyinsubfile{\renewcommand{\LtxDir}{../LaTeX/}}

% \renewcommand\LineNumber{\the\inputlineno}

\newcommand{\EOP}{\bar}
\newcommand{\BOP}{\underline}
\newcommand{\eop}{EOP}\newcommand{\bop}{BOP}

\begin{document}

\noindent Pablo,

We have been working to define what extensions/enhancements we would need to \texttt{dol[o/ark/ang]} to allow us to represent the structure of all the models we want to offer solution tools for in HARK.

The goals are:
\begin{enumerate}
\item Generality
  \begin{itemize}
  \item We hope to define a syntax/structure rich enough to handle anything that qualifies as a discrete-time Bellman problem with both discrete and continuous states (or, at least, rich enough that it can eventually be extended to handle any such)
  \end{itemize}
\item Flexibility
  \begin{itemize}
  \item  We want users to be able to hand-code whichever parts of the solution process they like (obviously, they \textit{must} hand-code any parts that cannot be handled by the built-in solution methods)
  \item In principle, this allows the framework to handle any problem, even ones that built-in solvers will fail at
  \end{itemize}
\item Modularity
  \begin{itemize}
  \item It should be as easy as possible to swap in or out different model components
    \begin{itemize}
    \item e.g., maybe you have a portfolio choice only once every third year
    \end{itemize}
  \end{itemize}
\end{enumerate}

As best we can see, all of these objectives could be accomplished by extending dol[o/ark/ang] in a few specific ways.

The most important is that, in the new scheme, there would be (or at least, \textit{could be} a set of dolang yaml files to represent the solution of a problem in a single period, instead of a single file.  The period could (if desired) be split into `stages' which get solved by sequential backwards induction.

Principles:
\begin{enumerate}
\item \texttt{symbols, definitions, calibration, calibration, domain, options} would be defined in the `period' yaml file
\end{enumerate}

\begin{itemize}
\item in which the end of period (`\eop') and beginning of period (`\bop') state are allowed to differ
\item in which there are no \texttt{definitions} (those should be defined at the level of a `period'
\end{itemize}


As we see it the `stage' yaml file would contain the following subset of the elements that are currently allowed in your yaml files:
\begin{itemize}
\item name, symbols, equations, value
  
\end{itemize}
and the stage object could be generated by a command like `opt

while a `period' yaml file would contain stages as well as 

The of course would require the user to guaranteee that when they append a further (backwards) element to the existing list of solutions, the new element is guaranteed to generate the state variables needed by its successor.

What we need from Dolo:
\begin{enumerate}
\item A syntax for defining \eop and \bop variables (or inheriting those definitions from a namespace)
  \begin{itemize}
  \item $\eop_{t} \leftrightarrow \bop_{t+1}$
    \begin{itemize}
    \item It is necessary to allow this, but not necessary to require it.  That is, infinite horizon models with an identical problem in successive steps could omit explicit definition of {\eop} and {\bop} variables and the code would interpret their absence as a requirement that the problem is identical in the next step
    \end{itemize}
  \end{itemize}
\item Transitions can occur without a timestep increment
  \begin{itemize}
  \item These correspond to multistage problems, like with labor, consumption, portfolio choice ...
  \end{itemize}
\item Variables within a time period cannot reference those in another time period
  \begin{itemize}
  \item This seems necessary for modularity
  \end{itemize}
\end{enumerate}
\hypertarget{ApndxSolutionSteps}{}

We want to construct both the solution and the simulation components of the problem as we move back from a final moment.

\begin{enumerate}
\item Backward/Expectation/Optimization: We are solving for chosen behavior giving beliefs (expectations) about the future
\item Forward/Experience/Simulation: We are experiencing the realization of the shocks that determine our states and making the precalculated choices
\end{enumerate}


\begin{enumerate}
\item There are three types of stages:
  \begin{enumerate}
  \item \texttt{transition} - (short `\texttt{trn}')
    \begin{itemize}
    \item Evolution in chrontime from end of a period to the beginning of the next (`tick')
    \item Example: a year of life
    \item Backward: structure of BOP$_{t+1}$ states creates structure of EOP$_{t}$ states
      \begin{itemize}
      \item e.g., k[t+1] grid defines a[t] grid
      \end{itemize}
    \item Forward: structure of EOP$_{t}$ states creates structure of BOP$_{t+1}$ states
      \begin{itemize}
      \item e.g., a[t] distribution becomes k[t+1] distribution
      \end{itemize}
    \end{itemize}
  \item \texttt{optimization} - (short `\texttt{opt}')
    \begin{itemize}
    \item Constructs the agent's choices
    \end{itemize}
  \item \texttt{exogenous} shocks - short \texttt{exo}
    \begin{itemize}
    \item Backward: Compute expectations required for model solution
    \item Forward: Propagate distributions according to eqns of motion
    \end{itemize}
  \end{enumerate}
\end{enumerate}
\end{document}

Principles:
\begin{itemize}
\item We want to be able to construct all our models by stringing together sequences of these stages.
\item Each stage has distinct beginning and end states
\item All stages within a period share a namespace
\item Stages within a period have no access to namespaces of prior or subsequent periods
  
\end{itemize}
\section{The Problem}

We start by assuming we are solving a problem exactly like the one in the \href{https://econ-ark.github.io/BufferStockTheory}{BufferStockTheory} (in the `normalized' section).

\begin{equation*}\label{eq:veqn}
  \begin{split}
    % \begin{align*}
    \vFunc_{t}(\mNrm_{t})  & = \max_{{\{\cFunc\}}_{t}^{T}}~  \uFunc(\cFunc_{t}) +\DiscFac \Ex_{t}[\PermGroFac_{t+1}^{1-\CRRA}\vFunc_{t+1}({\mNrm}_{t+1})]  \\
    & \mbox{s.t.}
    \\ {\aNrm}_{t}  & = \mNrm_{t}-c_{t}
    \\ {\kNrm}_{t+1} & = \aNrm_{t}/\PermGroFac_{t+1}
    \\ {\bNrm}_{t+1}  & = {\kNrm}_{t+1}\Rfree = (\Rfree/\PermGroFac_{t+1})\aNrm_{t}  ~ = ~ \RNrm_{t+1}\aNrm_{t}
    \\ \mNrm_{t+1}  & = \bNrm_{t+1}+\TranShkAll_{t+1}  ,
    % \end{align*}
  \end{split}
\end{equation*}
where $\RNrm_{t+1}\equiv (\Rfree/\PermGroFac_{t+1})$ is a `permanent-income-growth-normalized' return factor.


\section{Details of the Solution Procedure}\label{sec:ApndxSolutionSteps}

\makeatletter
\newcommand{\leqnomode}{\tagsleft@true}
\newcommand{\reqnomode}{\tagsleft@false}
\renewcommand\tagform@[1]{\maketag@@@{\ignorespaces#1\unskip\@@italiccorr}}
\makeatother
\leqnomode
\small

The solution is built backwards by executing a series of steps, which are defined in a \texttt{dolo} yaml file.


\begin{align*}
  \texttt{term\_v\_of\_m.yaml} & - & \qquad \text{defines }\BOP{v}(k)=\texttt{terminal.v\_of\_m}=0
                                     \texttt{term\_v\_of\_m.yaml} & - & \qquad \text{defines }\BOP{v}(k)=\texttt{terminal.v\_of\_m}=0
\end{align*}
\begin{alignat}{3}
  \text{date} &      &   \notag \text{Equation} & \qquad                       & \qquad \texttt{step\_type} \qquad & \qquad \text{origin}
  \\ T        & ~~~~ &   \EOP{v}(a)             & = 0                          & \texttt{terminal.v\_of\_a}        & \qquad \text{defined}
  \\ T        & ~~~~ &   u(c)                   & =                            & \texttt{terminal.reward}          & \qquad \text{defined}
  \\ T        & ~~~~ &   \cFunc(m)                   & = m                          & \texttt{terminal.decision}        & \qquad \text{constructed} \label{step:cFuncmake}
  \\ T        & ~~~~ & \MOP{v}(m)               & = u(\cFunc(m)) + \beta \EOP{v}(a) & \texttt{terminal.v\_of\_m}        & \qquad \text{defined}
\end{alignat}

\begin{align*}
  \texttt{term\_v\_of\_k.yaml} & - & \qquad \text{defines }\BOP{v}(k)=\texttt{terminal.v\_of\_m}=0
\end{align*}

\begin{alignat}{3}
  \text{date} &      &   \notag \text{Equation} & \qquad                       & \qquad \texttt{step\_type} \qquad & \qquad \text{origin}
  \\ T        & ~~~~ & \text{shocks:}           & \{\PermShk,\TranShk,\Risky\} & \texttt{terminal.exogenous}       & \qquad \text{defined} \label{step:term_exogenous}
  \\ T        & ~~~~ & \BOP{v}(k)               & = \Ex[\MOP{v}(m)]            & \texttt{terminal.v\_of\_k}        & \qquad \text{constructed} \label{step:term_expectorate}
\end{alignat}

% and we would therefore expect the terminal period to contain two substages: $\{\term\_v\_of\_m\}$ and $\{term\_v\_of\_k\}$

The transition between period $T-1$ and period $T$ is
\begin{alignat}{3}
  \text{date(s)}          &      &   \notag \text{Equation} & \qquad                   & \qquad \texttt{step\_type} \qquad & %\qquad \text{comment}
  \\ T-1\leftrightarrow T & ~~~~ & k_{t+1}                  & = a_{t}                  & \texttt{transition\_state}        &  \label{step:transtate}
  \\ T-1\leftrightarrow T & ~~~~ & \EOP{v}_{t}(a_{t})       & = \BOP{v}_{t+1}(k_{t+1}) & \texttt{transition\_value}        & \label{step:tranfunc}
\end{alignat}

We would again define the problem in period $T-1$ as having two substages:

\texttt{cstage\_v\_of\_m}:
\begin{alignat}{3}
  \text{date(s)}              &      &   \notag \text{Equation} & \qquad                          & \qquad \texttt{step\_type} \qquad & \qquad \text{comment}
  \\ T-1                    & ~~~~ & \beta                 & =                               & \texttt{stage\_opt\_cns.DiscFac}           & \label{step:discounting}
  \\ T-1                    & ~~~~ &   u(c)                & =                               & \texttt{stage\_opt\_cns.reward}            & 
  \\ T-1                    & ~~~~ &   \mathfrak{c}(a)     & =                               & \texttt{stage\_opt\_cns.EGM}               & \qquad \text{consumed}
  \\ T-1                    & ~~~~ &   \cFunc(m)                &                                 & \texttt{stage\_opt\_cns.decision}          & \qquad \text{constructed} \label{step:cFuncMake}
  \\ T-1                    & ~~~~ & \MOP{v}(m)                  & = u(\cFunc(m))+\beta \EOP{v}(m-\cFunc(m)) & \texttt{stage\_opt\_cns.v\_of\_m}          &
\end{alignat}

\texttt{cstage\_v\_of\_k}:
\begin{alignat}{3}
  \text{date(s)}              &      &   \notag \text{Equation} & \qquad                          & \qquad \texttt{step\_type} \qquad & \qquad \text{comment}
  \\ T-1                    & ~~~~ & \text{shocks}    &                                 & \texttt{stage\_opt\_cns.exogenous}          & \label{step:stage_exogenous}
  \\ T-1                    & ~~~~ & \BOP{v}(k) & = \Ex[\MOP{v}(m)]                     & \texttt{stage\_opt\_cns.expect}          & \label{step:stage_expectorate}
\end{alignat}


This schema illustrates several points.


\begin{enumerate}
\item The choice of whether to identify the `shocks' as becoming known instantaneously after the beginning of period $T$ or instantaneously before the end of $T-1$ is mathematically and computationally arbitrary.
  \begin{enumerate}
  \item `arbitrary' in the sense that is just a question of labeling; the computations are identical whichever scheme is chosen
  \item The scheme above is my preferred, new way of doing it, because we ran into confusions in the old way of doing things where the expectation now taken in step \ref{step:term_expectorate} was taken at the end of the prior period (resulting in the infamous Gothic $\mathfrak{v}$).  
  \item The old scheme has the advantage (which is also its disadvantage) that the $k_{t+1}$ variable need not be defined.  We could just redefine step \ref{step:tranfunc} as $\EOP{v}_{t}(a_{t}) = \Ex_{t}[\MOP{v}_{t+1}(a_{t+1} \mathcal{R}_{t+1} + \theta_{t+1})]$ (where the new notation of $\EOP{v}$ is equivalent to the old $\mathfrak{v}(a)$, and $\mathcal{R}=\Rfree / (\psi \PermGroFac)$, and eliminate step \ref{step:transtate} as superflous.  

  \end{enumerate}

  \pagebreak

\item There is a clean separation between the `transition' phase (lines~\ref{step:transtate}-\ref{step:tranfunc}, which connects adjacent periods, and the remaining steps (\ref{step:discounting}-\ref{step:stage_expectorate}), which build the solution to the problem by executing a series of steps in order.  Let's call this collection of steps \texttt{stage\_opt\_cns-solve}.
\item No subscripts are needed for variables used in \texttt{stage\_opt\_cns-solve} because the whole point of declaring this to be period $T$ is that no variable in that namespace can retrieve anything from any other period.
\item What we mainly care about is the consumption function, which is constructed in step \ref{step:cFuncMake}.  The exactly identical numerical consumption function is created regardless of which period we do the expectation calculations in.
\end{enumerate}


Now, if we define \texttt{transtage} as comprising steps \ref{step:transtate}-\ref{step:tranfunc}, the remainder of the problem is constructed by iterating the two elements:
Then the problem in period $T-1$ is like this:
\begin{alignat}{3}
  \text{date(s)}              &      &   \notag       \qquad \texttt{stage\_type} \qquad
  \\ T-2\leftrightarrow T-1 & ~~~~ & \text{\texttt{transtage}}
  \\ T-2 & ~~~~ & \text{\texttt{stage\_opt\_cns-solve}}
  \\ T-3\leftrightarrow T-2 & ~~~~ & \text{\texttt{transtage}}
  \\ T-3 & ~~~~ & \text{\texttt{stage\_opt\_cns-solve}}
\end{alignat}

It would consist of steps like this:
\begin{alignat}{3}
  \text{date(s)}              &      &   \notag       \qquad \texttt{stage\_type} \qquad
  \\ T-2\leftrightarrow T-1 & ~~~~ & \text{\texttt{transtage}}
  \\ T-2 & ~~~~ & \text{\texttt{stage\_opt\_cns-solve}}
  \\ T-3\leftrightarrow T-2 & ~~~~ & \text{\texttt{transtage}}
  \\ T-3 & ~~~~ & \text{\texttt{stage\_opt\_cns-solve}}
\end{alignat}

Now suppose we want to add a portfolio stage to the problem.  Specifically, we will assume that right after the beginning of period $t$, before the shocks are realized, the consumer must make a choice about the proportion $\varsigma$ of capital $k$ to be committed to risky asset that will earn return $\Risky$ and the proportion $(1-\varsigma)$ that will earn $\Rfree$, for a combined portfolio return of $\mathbb{R}=\varsigma \Risky + (1-\varsigma)\Rfree = \Rfree+\varsigma(\Risky-\Rfree)$.

The problem now has an extra stage to it:
\begin{align*}
  \BOP{v}(k) & = \max_{\varsigma} \Ex[\MOP{v}(\overbrace{(\mathbb{R}/(\PermGroFac \PermShk))k+\TranShk)}^{\equiv m})]
\end{align*}

The first order condition for this problem is well-known, and this whole portfolio optimization problem can therefore be bundled up into a \texttt{portfolio} stage that takes $k$ as a beginning-of-period input and yields $k$ and $\varsigma$ as outputs.

Thanks to the modularity of the ways in which we have laid out the problem, it will now be possible simply to drop the portfolio stage into the appropriate point in the sequence of steps used earlier to define \texttt{stage\_opt\_cns-solve}.  Suppose we call the modified set of steps \texttt{stage\_opt\_cns-with-portfolio-solve}:\pagebreak
\begin{alignat*}{3}
  \text{backsteps} &      &   \notag \text{Equation} & \qquad                                    & \qquad \texttt{step\_type} \qquad  & \qquad \text{comment}
  \\ 0             & ~~~~ & \beta                    & =                                         & \texttt{stage\_opt\_cns.DiscFac}   & %\label{step:discounting}
  \\ 1             & ~~~~ &   u(c)                   & =                                         & \texttt{stage\_opt\_cns.reward}    & 
  \\ 2             & ~~~~ &   \mathfrak{c}(a)        & =                                         & \texttt{stage\_opt\_cns.EGM}       & \qquad \text{consumed}
  \\ 3             & ~~~~ &   \cFunc(m)              &                                           & \texttt{stage\_opt\_cns.decision}  & \qquad \text{constructed} %\label{step:cFuncMake}
  \\ 4             & ~~~~ & \MOP{v}(m)               & = u(\cFunc(m))+\beta \EOP{v}(m-\cFunc(m)) & \texttt{stage\_opt\_cns.v\_of\_m}  &
  \\ 5             & ~~~~ & \text{shocks}            &                                           & \texttt{stage\_opt\_cns.exogenous} & %\label{step:stage_exogenous}
  \\ 6             & ~~~~ &                          & \texttt{portfolio}                        &
  \\ 7             & ~~~~ & \BOP{v}(k)               & = \Ex[\MOP{v}(m)]                         & \texttt{stage\_opt\_cns.expect}    & %\label{step:stage_expectorate}
\end{alignat*}


The beauty of this scheme is that we can now add a portfolio choice wherever we want:
\begin{alignat}{3}
  \text{date(s)}            &      &   \notag      \qquad \texttt{stage\_type} \qquad
  \\ T-3\leftrightarrow T-4 & ~~~~ & \text{\texttt{transtage}}
  \\ T-4                    & ~~~~ & \text{\texttt{stage\_opt\_cns-with-portfolio-solve}}
  \\ T-4\leftrightarrow T-5 & ~~~~ & \text{\texttt{transtage}}
  \\ T-5                    & ~~~~ & \text{\texttt{stage\_opt\_cns-with-portfolio-solve}}
  \\ T-5\leftrightarrow T-6 & ~~~~ & \text{\texttt{transtage}}
  \\ T-6                    & ~~~~ & \text{\texttt{stage\_opt\_cns-solve}}
\end{alignat}

This sequence would define a problem in which the consumer has no portfolio choice in periods $T$ through $T-3$ but then has a portfolio choice in periods $T-4$ and $T-5$, followed by a $T-6$ with no portfolio choice again.  It is easy to seen now how this way of doing things allows us modularly to add as many stages as we like to a particular period.  (Each `stage' should be a simple problem disciplined by the requirements of a Dol[o/ARK] yaml file; but we can string together as may such stages as we like, as long as the requirements of the successive stages are mutually satisfied).

Finally, notice that if we were to say that the job of the user of the toolkit is to provide an algorithm for the construction of the prior period, given the existing length of the problem, we sidestep all the complicated questions about defining in advance what is time varying and what is time invariant, etc.  Subject to the constraint of compatibility of the transition process between $t$ and $t-1$ the user has complete freedom to rewrite anything at all as the stage that comes before all the prior stages.  They can set the interest factor, the time preference rate, beliefs about the magnitude of stock market fluctuations, to whatever they like.  The constructive machinery would record the assumptions that would be made, and those records would define the sequence of values of (potentially) time-varying objects.

Notice further how easy it is to add a discrete choice component to this.  Suppose the problem is one of durable good adjustment (buy/sell my car).  Call the two options ``stay'' and ``move''.  

\begin{alignat}{3}
  \text{date(s)}              &      &   \notag      \qquad \texttt{stage\_type} \qquad
  \\ T-5\leftrightarrow T-6 & ~~~~ & \text{\texttt{transtage}}
  \\ T-6 & ~~~~ & \text{\{\texttt{stagemove},\texttt{stagestay}\}}
  \\ T-6 & ~~~~ & \text{\texttt{choose-move-or-stay}}
\end{alignat}

Where \texttt{choose-move-or-stay} just decides, for each configuration of state variables, which option yields the highest value.

This is how we should have done things from the start.
\end{document}

\endinput

% Local Variables:
% eval: (setq TeX-command-list  (assq-delete-all (car (assoc "BibTeX" TeX-command-list)) TeX-command-list))
% eval: (setq TeX-command-list  (assq-delete-all (car (assoc "BibTeX" TeX-command-list)) TeX-command-list))
% eval: (setq TeX-command-list  (assq-delete-all (car (assoc "BibTeX" TeX-command-list)) TeX-command-list))
% eval: (setq TeX-command-list  (assq-delete-all (car (assoc "BibTeX" TeX-command-list)) TeX-command-list))
% eval: (setq TeX-command-list  (assq-delete-all (car (assoc "Biber"  TeX-command-list)) TeX-command-list))
% eval: (add-to-list 'TeX-command-list '("BibTeX" "bibtex ../LaTeX/%s" TeX-run-BibTeX nil t                                                                              :help "Run BibTeX") t)
% eval: (add-to-list 'TeX-command-list '("BibTeX" "bibtex ../LaTeX/%s" TeX-run-BibTeX nil (plain-tex-mode latex-mode doctex-mode ams-tex-mode texinfo-mode context-mode) :help "Run BibTeX") t)
% TeX-PDF-mode: t
% TeX-file-line-error: t
% TeX-debug-warnings: t
% LaTeX-command-style: (("" "%(PDF)%(latex) %(file-line-error) %(extraopts) -output-directory=../LaTeX %S%(PDFout)"))
% TeX-source-correlate-mode: t
% TeX-parse-self: t
% eval: (cond ((string-equal system-type "darwin") (progn (setq TeX-view-program-list '(("Skim" "/Applications/Skim.app/Contents/SharedSupport/displayline -b %n ../LaTeX/%o %b"))))))
% eval: (cond ((string-equal system-type "gnu/linux") (progn (setq TeX-view-program-list '(("Evince" "evince --page-index=%(outpage) ../LaTeX/%o"))))))
% eval: (cond ((string-equal system-type "gnu/linux") (progn (setq TeX-view-program-selection '((output-pdf "Evince"))))))
% TeX-parse-all-errors: t
% End:
